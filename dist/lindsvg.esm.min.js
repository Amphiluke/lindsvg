/*!
lindsvg v1.0.0
https://github.com/Amphiluke/lindsvg#readme
(c) 2020 Amphiluke
*/
let t={AXIOM:"Axiom may only contain the following characters: A..Z,+,-,[,]",RULE:"Production rules may only contain the following characters: A..Z,+,-,[,]",LETTER:"Allowed alphabet letters are: A..Z",ALPHA:"The “alpha” parameter must be a finite number",THETA:"The “theta” parameter must be a finite number",STEP:"The “step” parameter must be a positive finite number",COUNT:"The number of iterations must be integer and finite",NUMBER:"A valid finite number expected"},e=/^[A-Z]$/;let a=/^[A-Z+\-[\]]*$/;function i(e,i=t.RULE){return a.test(e)||i}function n(a,n,r){let s=new Map;return Object.entries(a).forEach(([a,h])=>{let o=function(a,i=t.LETTER){return e.test(a)||i}(a,n);!0===o&&(o=i(h,r)),!0!==o&&s.set(a,o)}),!s.size||s}function r(e){let a=new Map;return Object.entries(e).forEach(([e,r])=>{let s=!0;switch(e){case"axiom":s=i(r,t.AXIOM);break;case"rules":s=n(r);break;case"alpha":case"theta":s=function(e,a=t.NUMBER){return Number.isFinite(e)||a}(r,t[e.toUpperCase()]);break;case"step":s=function(e,a=t.STEP){return Number.isFinite(e)&&e>0||a}(r);break;case"iterations":s=function(e,a=t.COUNT){return Number.isInteger(e)&&e>0||a}(r)}!0!==s&&a.set(e,s)}),!a.size||a}let s={F:"",B:"","+":"+","-":"-","[":"[","]":"]"},h={alpha:0,theta:0,step:10,iterations:3};function o(t){let e=r(t);if(!0!==e)throw new Error(function t(e){return[...e].reduce((e,[a,i])=>i instanceof Map?`${e}\n${a}:${t(i).replace(/\n/g,"\n  ")}`:`${e}\n${a}: ${i}`,"")}(e));let{axiom:a,iterations:i}={...h,...t},n={...s,...t.rules};for(;i>0;i--)a=[...a].reduce((t,e)=>t+(n[e]||""),"");return a}let c={translate(){this.x+=this.step*Math.cos(this.alpha),this.y+=this.step*Math.sin(this.alpha),this.minX=Math.min(this.minX,this.x),this.maxX=Math.max(this.maxX,this.x),this.minY=Math.min(this.minY,this.y),this.maxY=Math.max(this.maxY,this.y)},rotate(t){this.alpha+=t*this.theta},pushStack(){this.stack.push({x:this.x,y:this.y,alpha:this.alpha})},popStack(){({x:this.x,y:this.y,alpha:this.alpha}=this.stack.pop())},getDrawingRect(){let t=Math.floor(this.minX),e=Math.floor(this.minY),a=Math.ceil(this.maxX),i=Math.ceil(this.maxY);return{minX:t,minY:e,maxX:a,maxY:i,width:a-t,height:i-e}}};function l(t,e){return`${+t.toFixed(4)} ${+e.toFixed(4)}`}function u(t){let e=o(t),a=function({x:t,y:e,step:a,alpha:i,theta:n}){let r=Object.create(c);return r.stack=[],r.x=r.minX=r.maxX=t,r.y=r.minY=r.maxY=e,r.step=a,r.alpha=-i,r.theta=n,r}({x:0,y:0,...t});return{pathData:function(t,e){let a;return[...t].reduce((t,i)=>{switch(i){case"F":e.translate(),t+=("L"===a?" ":"L")+l(e.x,e.y),a="L";break;case"B":e.translate(),t+=("M"===a?" ":"M")+l(e.x,e.y),a="M";break;case"+":e.rotate(1);break;case"-":e.rotate(-1);break;case"[":e.pushStack();break;case"]":e.popStack(),t+=`M${l(e.x,e.y)}`,a="M"}return t},"M"+l(e.x,e.y))}(function(t){return t.replace(/[^FB[\]+-]/g,"")}(e),a),...a.getDrawingRect()}}function m(t,e){let{pathData:a,minX:i,minY:n,width:r,height:s}=u(t);return`<svg xmlns="http://www.w3.org/2000/svg" viewBox="${i} ${n} ${r} ${s}" height="${(e={width:r,height:s,fill:"none",stroke:"#000",...e}).height}" width="${e.width}">\n  <path d="${a}" fill="${e.fill}" stroke="${e.stroke}"></path>\n</svg>`}export{m as getSVGCode,u as getSVGData};
